// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensors.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sensors_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sensors_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3015000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3015008 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sensors_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sensors_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_sensors_2eproto;
namespace sensors {
class Cam;
struct CamDefaultTypeInternal;
extern CamDefaultTypeInternal _Cam_default_instance_;
class Can;
struct CanDefaultTypeInternal;
extern CanDefaultTypeInternal _Can_default_instance_;
class Gps;
struct GpsDefaultTypeInternal;
extern GpsDefaultTypeInternal _Gps_default_instance_;
class Imu;
struct ImuDefaultTypeInternal;
extern ImuDefaultTypeInternal _Imu_default_instance_;
class Lidar;
struct LidarDefaultTypeInternal;
extern LidarDefaultTypeInternal _Lidar_default_instance_;
class Lidar_xyz;
struct Lidar_xyzDefaultTypeInternal;
extern Lidar_xyzDefaultTypeInternal _Lidar_xyz_default_instance_;
}  // namespace sensors
PROTOBUF_NAMESPACE_OPEN
template<> ::sensors::Cam* Arena::CreateMaybeMessage<::sensors::Cam>(Arena*);
template<> ::sensors::Can* Arena::CreateMaybeMessage<::sensors::Can>(Arena*);
template<> ::sensors::Gps* Arena::CreateMaybeMessage<::sensors::Gps>(Arena*);
template<> ::sensors::Imu* Arena::CreateMaybeMessage<::sensors::Imu>(Arena*);
template<> ::sensors::Lidar* Arena::CreateMaybeMessage<::sensors::Lidar>(Arena*);
template<> ::sensors::Lidar_xyz* Arena::CreateMaybeMessage<::sensors::Lidar_xyz>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sensors {

enum ChannelOrder : int {
  GRAYSCALE = 0,
  BGR = 1,
  RGB = 2,
  BGRA = 3,
  RGBA = 4,
  OPTICAL_FLOW = 5,
  ChannelOrder_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ChannelOrder_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ChannelOrder_IsValid(int value);
constexpr ChannelOrder ChannelOrder_MIN = GRAYSCALE;
constexpr ChannelOrder ChannelOrder_MAX = OPTICAL_FLOW;
constexpr int ChannelOrder_ARRAYSIZE = ChannelOrder_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChannelOrder_descriptor();
template<typename T>
inline const std::string& ChannelOrder_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChannelOrder>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChannelOrder_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChannelOrder_descriptor(), enum_t_value);
}
inline bool ChannelOrder_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChannelOrder* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChannelOrder>(
    ChannelOrder_descriptor(), name, value);
}
// ===================================================================

class Gps PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.Gps) */ {
 public:
  inline Gps() : Gps(nullptr) {}
  ~Gps() override;
  explicit constexpr Gps(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Gps(const Gps& from);
  Gps(Gps&& from) noexcept
    : Gps() {
    *this = ::std::move(from);
  }

  inline Gps& operator=(const Gps& from) {
    CopyFrom(from);
    return *this;
  }
  inline Gps& operator=(Gps&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Gps& default_instance() {
    return *internal_default_instance();
  }
  static inline const Gps* internal_default_instance() {
    return reinterpret_cast<const Gps*>(
               &_Gps_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Gps& a, Gps& b) {
    a.Swap(&b);
  }
  inline void Swap(Gps* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Gps* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Gps* New() const final {
    return CreateMaybeMessage<Gps>(nullptr);
  }

  Gps* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Gps>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Gps& from);
  void MergeFrom(const Gps& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Gps* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.Gps";
  }
  protected:
  explicit Gps(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatitudeFieldNumber = 1,
    kLongitudeFieldNumber = 2,
    kHorizontalDilutionOfPrecisionFieldNumber = 3,
  };
  // double latitude = 1;
  void clear_latitude();
  double latitude() const;
  void set_latitude(double value);
  private:
  double _internal_latitude() const;
  void _internal_set_latitude(double value);
  public:

  // double longitude = 2;
  void clear_longitude();
  double longitude() const;
  void set_longitude(double value);
  private:
  double _internal_longitude() const;
  void _internal_set_longitude(double value);
  public:

  // double horizontalDilutionOfPrecision = 3;
  void clear_horizontaldilutionofprecision();
  double horizontaldilutionofprecision() const;
  void set_horizontaldilutionofprecision(double value);
  private:
  double _internal_horizontaldilutionofprecision() const;
  void _internal_set_horizontaldilutionofprecision(double value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.Gps)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double latitude_;
  double longitude_;
  double horizontaldilutionofprecision_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class Imu PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.Imu) */ {
 public:
  inline Imu() : Imu(nullptr) {}
  ~Imu() override;
  explicit constexpr Imu(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Imu(const Imu& from);
  Imu(Imu&& from) noexcept
    : Imu() {
    *this = ::std::move(from);
  }

  inline Imu& operator=(const Imu& from) {
    CopyFrom(from);
    return *this;
  }
  inline Imu& operator=(Imu&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Imu& default_instance() {
    return *internal_default_instance();
  }
  static inline const Imu* internal_default_instance() {
    return reinterpret_cast<const Imu*>(
               &_Imu_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Imu& a, Imu& b) {
    a.Swap(&b);
  }
  inline void Swap(Imu* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Imu* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Imu* New() const final {
    return CreateMaybeMessage<Imu>(nullptr);
  }

  Imu* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Imu>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Imu& from);
  void MergeFrom(const Imu& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Imu* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.Imu";
  }
  protected:
  explicit Imu(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScaledAccelXFieldNumber = 1,
    kScaledAccelYFieldNumber = 2,
    kScaledAccelZFieldNumber = 3,
  };
  // float scaledAccelX = 1;
  void clear_scaledaccelx();
  float scaledaccelx() const;
  void set_scaledaccelx(float value);
  private:
  float _internal_scaledaccelx() const;
  void _internal_set_scaledaccelx(float value);
  public:

  // float scaledAccelY = 2;
  void clear_scaledaccely();
  float scaledaccely() const;
  void set_scaledaccely(float value);
  private:
  float _internal_scaledaccely() const;
  void _internal_set_scaledaccely(float value);
  public:

  // float scaledAccelZ = 3;
  void clear_scaledaccelz();
  float scaledaccelz() const;
  void set_scaledaccelz(float value);
  private:
  float _internal_scaledaccelz() const;
  void _internal_set_scaledaccelz(float value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.Imu)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float scaledaccelx_;
  float scaledaccely_;
  float scaledaccelz_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class Cam PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.Cam) */ {
 public:
  inline Cam() : Cam(nullptr) {}
  ~Cam() override;
  explicit constexpr Cam(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Cam(const Cam& from);
  Cam(Cam&& from) noexcept
    : Cam() {
    *this = ::std::move(from);
  }

  inline Cam& operator=(const Cam& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cam& operator=(Cam&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Cam& default_instance() {
    return *internal_default_instance();
  }
  static inline const Cam* internal_default_instance() {
    return reinterpret_cast<const Cam*>(
               &_Cam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Cam& a, Cam& b) {
    a.Swap(&b);
  }
  inline void Swap(Cam* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Cam* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Cam* New() const final {
    return CreateMaybeMessage<Cam>(nullptr);
  }

  Cam* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Cam>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Cam& from);
  void MergeFrom(const Cam& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Cam* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.Cam";
  }
  protected:
  explicit Cam(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageDataFieldNumber = 3,
    kColsFieldNumber = 1,
    kRowsFieldNumber = 2,
  };
  // bytes image_data = 3;
  void clear_image_data();
  const std::string& image_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image_data();
  std::string* release_image_data();
  void set_allocated_image_data(std::string* image_data);
  private:
  const std::string& _internal_image_data() const;
  void _internal_set_image_data(const std::string& value);
  std::string* _internal_mutable_image_data();
  public:

  // int32 cols = 1;
  void clear_cols();
  ::PROTOBUF_NAMESPACE_ID::int32 cols() const;
  void set_cols(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_cols() const;
  void _internal_set_cols(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 rows = 2;
  void clear_rows();
  ::PROTOBUF_NAMESPACE_ID::int32 rows() const;
  void set_rows(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rows() const;
  void _internal_set_rows(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.Cam)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_data_;
  ::PROTOBUF_NAMESPACE_ID::int32 cols_;
  ::PROTOBUF_NAMESPACE_ID::int32 rows_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class Lidar_xyz PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.Lidar.xyz) */ {
 public:
  inline Lidar_xyz() : Lidar_xyz(nullptr) {}
  ~Lidar_xyz() override;
  explicit constexpr Lidar_xyz(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Lidar_xyz(const Lidar_xyz& from);
  Lidar_xyz(Lidar_xyz&& from) noexcept
    : Lidar_xyz() {
    *this = ::std::move(from);
  }

  inline Lidar_xyz& operator=(const Lidar_xyz& from) {
    CopyFrom(from);
    return *this;
  }
  inline Lidar_xyz& operator=(Lidar_xyz&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Lidar_xyz& default_instance() {
    return *internal_default_instance();
  }
  static inline const Lidar_xyz* internal_default_instance() {
    return reinterpret_cast<const Lidar_xyz*>(
               &_Lidar_xyz_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Lidar_xyz& a, Lidar_xyz& b) {
    a.Swap(&b);
  }
  inline void Swap(Lidar_xyz* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Lidar_xyz* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Lidar_xyz* New() const final {
    return CreateMaybeMessage<Lidar_xyz>(nullptr);
  }

  Lidar_xyz* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Lidar_xyz>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Lidar_xyz& from);
  void MergeFrom(const Lidar_xyz& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Lidar_xyz* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.Lidar.xyz";
  }
  protected:
  explicit Lidar_xyz(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.Lidar.xyz)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float x_;
  float y_;
  float z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class Lidar PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.Lidar) */ {
 public:
  inline Lidar() : Lidar(nullptr) {}
  ~Lidar() override;
  explicit constexpr Lidar(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Lidar(const Lidar& from);
  Lidar(Lidar&& from) noexcept
    : Lidar() {
    *this = ::std::move(from);
  }

  inline Lidar& operator=(const Lidar& from) {
    CopyFrom(from);
    return *this;
  }
  inline Lidar& operator=(Lidar&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Lidar& default_instance() {
    return *internal_default_instance();
  }
  static inline const Lidar* internal_default_instance() {
    return reinterpret_cast<const Lidar*>(
               &_Lidar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Lidar& a, Lidar& b) {
    a.Swap(&b);
  }
  inline void Swap(Lidar* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Lidar* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Lidar* New() const final {
    return CreateMaybeMessage<Lidar>(nullptr);
  }

  Lidar* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Lidar>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Lidar& from);
  void MergeFrom(const Lidar& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Lidar* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.Lidar";
  }
  protected:
  explicit Lidar(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Lidar_xyz xyz;

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kSizeFieldNumber = 1,
  };
  // repeated .sensors.Lidar.xyz data = 2;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::sensors::Lidar_xyz* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Lidar_xyz >*
      mutable_data();
  private:
  const ::sensors::Lidar_xyz& _internal_data(int index) const;
  ::sensors::Lidar_xyz* _internal_add_data();
  public:
  const ::sensors::Lidar_xyz& data(int index) const;
  ::sensors::Lidar_xyz* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Lidar_xyz >&
      data() const;

  // float size = 1;
  void clear_size();
  float size() const;
  void set_size(float value);
  private:
  float _internal_size() const;
  void _internal_set_size(float value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.Lidar)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Lidar_xyz > data_;
  float size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class Can PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sensors.Can) */ {
 public:
  inline Can() : Can(nullptr) {}
  ~Can() override;
  explicit constexpr Can(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Can(const Can& from);
  Can(Can&& from) noexcept
    : Can() {
    *this = ::std::move(from);
  }

  inline Can& operator=(const Can& from) {
    CopyFrom(from);
    return *this;
  }
  inline Can& operator=(Can&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Can& default_instance() {
    return *internal_default_instance();
  }
  static inline const Can* internal_default_instance() {
    return reinterpret_cast<const Can*>(
               &_Can_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Can& a, Can& b) {
    a.Swap(&b);
  }
  inline void Swap(Can* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Can* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Can* New() const final {
    return CreateMaybeMessage<Can>(nullptr);
  }

  Can* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Can>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Can& from);
  void MergeFrom(const Can& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Can* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sensors.Can";
  }
  protected:
  explicit Can(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // float type = 1;
  void clear_type();
  float type() const;
  void set_type(float value);
  private:
  float _internal_type() const;
  void _internal_set_type(float value);
  public:

  // float data = 2;
  void clear_data();
  float data() const;
  void set_data(float value);
  private:
  float _internal_data() const;
  void _internal_set_data(float value);
  public:

  // @@protoc_insertion_point(class_scope:sensors.Can)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float type_;
  float data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Gps

// double latitude = 1;
inline void Gps::clear_latitude() {
  latitude_ = 0;
}
inline double Gps::_internal_latitude() const {
  return latitude_;
}
inline double Gps::latitude() const {
  // @@protoc_insertion_point(field_get:sensors.Gps.latitude)
  return _internal_latitude();
}
inline void Gps::_internal_set_latitude(double value) {
  
  latitude_ = value;
}
inline void Gps::set_latitude(double value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:sensors.Gps.latitude)
}

// double longitude = 2;
inline void Gps::clear_longitude() {
  longitude_ = 0;
}
inline double Gps::_internal_longitude() const {
  return longitude_;
}
inline double Gps::longitude() const {
  // @@protoc_insertion_point(field_get:sensors.Gps.longitude)
  return _internal_longitude();
}
inline void Gps::_internal_set_longitude(double value) {
  
  longitude_ = value;
}
inline void Gps::set_longitude(double value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:sensors.Gps.longitude)
}

// double horizontalDilutionOfPrecision = 3;
inline void Gps::clear_horizontaldilutionofprecision() {
  horizontaldilutionofprecision_ = 0;
}
inline double Gps::_internal_horizontaldilutionofprecision() const {
  return horizontaldilutionofprecision_;
}
inline double Gps::horizontaldilutionofprecision() const {
  // @@protoc_insertion_point(field_get:sensors.Gps.horizontalDilutionOfPrecision)
  return _internal_horizontaldilutionofprecision();
}
inline void Gps::_internal_set_horizontaldilutionofprecision(double value) {
  
  horizontaldilutionofprecision_ = value;
}
inline void Gps::set_horizontaldilutionofprecision(double value) {
  _internal_set_horizontaldilutionofprecision(value);
  // @@protoc_insertion_point(field_set:sensors.Gps.horizontalDilutionOfPrecision)
}

// -------------------------------------------------------------------

// Imu

// float scaledAccelX = 1;
inline void Imu::clear_scaledaccelx() {
  scaledaccelx_ = 0;
}
inline float Imu::_internal_scaledaccelx() const {
  return scaledaccelx_;
}
inline float Imu::scaledaccelx() const {
  // @@protoc_insertion_point(field_get:sensors.Imu.scaledAccelX)
  return _internal_scaledaccelx();
}
inline void Imu::_internal_set_scaledaccelx(float value) {
  
  scaledaccelx_ = value;
}
inline void Imu::set_scaledaccelx(float value) {
  _internal_set_scaledaccelx(value);
  // @@protoc_insertion_point(field_set:sensors.Imu.scaledAccelX)
}

// float scaledAccelY = 2;
inline void Imu::clear_scaledaccely() {
  scaledaccely_ = 0;
}
inline float Imu::_internal_scaledaccely() const {
  return scaledaccely_;
}
inline float Imu::scaledaccely() const {
  // @@protoc_insertion_point(field_get:sensors.Imu.scaledAccelY)
  return _internal_scaledaccely();
}
inline void Imu::_internal_set_scaledaccely(float value) {
  
  scaledaccely_ = value;
}
inline void Imu::set_scaledaccely(float value) {
  _internal_set_scaledaccely(value);
  // @@protoc_insertion_point(field_set:sensors.Imu.scaledAccelY)
}

// float scaledAccelZ = 3;
inline void Imu::clear_scaledaccelz() {
  scaledaccelz_ = 0;
}
inline float Imu::_internal_scaledaccelz() const {
  return scaledaccelz_;
}
inline float Imu::scaledaccelz() const {
  // @@protoc_insertion_point(field_get:sensors.Imu.scaledAccelZ)
  return _internal_scaledaccelz();
}
inline void Imu::_internal_set_scaledaccelz(float value) {
  
  scaledaccelz_ = value;
}
inline void Imu::set_scaledaccelz(float value) {
  _internal_set_scaledaccelz(value);
  // @@protoc_insertion_point(field_set:sensors.Imu.scaledAccelZ)
}

// -------------------------------------------------------------------

// Cam

// int32 cols = 1;
inline void Cam::clear_cols() {
  cols_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Cam::_internal_cols() const {
  return cols_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Cam::cols() const {
  // @@protoc_insertion_point(field_get:sensors.Cam.cols)
  return _internal_cols();
}
inline void Cam::_internal_set_cols(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  cols_ = value;
}
inline void Cam::set_cols(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_cols(value);
  // @@protoc_insertion_point(field_set:sensors.Cam.cols)
}

// int32 rows = 2;
inline void Cam::clear_rows() {
  rows_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Cam::_internal_rows() const {
  return rows_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Cam::rows() const {
  // @@protoc_insertion_point(field_get:sensors.Cam.rows)
  return _internal_rows();
}
inline void Cam::_internal_set_rows(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  rows_ = value;
}
inline void Cam::set_rows(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rows(value);
  // @@protoc_insertion_point(field_set:sensors.Cam.rows)
}

// bytes image_data = 3;
inline void Cam::clear_image_data() {
  image_data_.ClearToEmpty();
}
inline const std::string& Cam::image_data() const {
  // @@protoc_insertion_point(field_get:sensors.Cam.image_data)
  return _internal_image_data();
}
template <typename ArgT0, typename... ArgT>
PROTOBUF_ALWAYS_INLINE
inline void Cam::set_image_data(ArgT0&& arg0, ArgT... args) {
 
 image_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArena());
  // @@protoc_insertion_point(field_set:sensors.Cam.image_data)
}
inline std::string* Cam::mutable_image_data() {
  // @@protoc_insertion_point(field_mutable:sensors.Cam.image_data)
  return _internal_mutable_image_data();
}
inline const std::string& Cam::_internal_image_data() const {
  return image_data_.Get();
}
inline void Cam::_internal_set_image_data(const std::string& value) {
  
  image_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline std::string* Cam::_internal_mutable_image_data() {
  
  return image_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Cam::release_image_data() {
  // @@protoc_insertion_point(field_release:sensors.Cam.image_data)
  return image_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Cam::set_allocated_image_data(std::string* image_data) {
  if (image_data != nullptr) {
    
  } else {
    
  }
  image_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), image_data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:sensors.Cam.image_data)
}

// -------------------------------------------------------------------

// Lidar_xyz

// float x = 1;
inline void Lidar_xyz::clear_x() {
  x_ = 0;
}
inline float Lidar_xyz::_internal_x() const {
  return x_;
}
inline float Lidar_xyz::x() const {
  // @@protoc_insertion_point(field_get:sensors.Lidar.xyz.x)
  return _internal_x();
}
inline void Lidar_xyz::_internal_set_x(float value) {
  
  x_ = value;
}
inline void Lidar_xyz::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:sensors.Lidar.xyz.x)
}

// float y = 2;
inline void Lidar_xyz::clear_y() {
  y_ = 0;
}
inline float Lidar_xyz::_internal_y() const {
  return y_;
}
inline float Lidar_xyz::y() const {
  // @@protoc_insertion_point(field_get:sensors.Lidar.xyz.y)
  return _internal_y();
}
inline void Lidar_xyz::_internal_set_y(float value) {
  
  y_ = value;
}
inline void Lidar_xyz::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:sensors.Lidar.xyz.y)
}

// float z = 3;
inline void Lidar_xyz::clear_z() {
  z_ = 0;
}
inline float Lidar_xyz::_internal_z() const {
  return z_;
}
inline float Lidar_xyz::z() const {
  // @@protoc_insertion_point(field_get:sensors.Lidar.xyz.z)
  return _internal_z();
}
inline void Lidar_xyz::_internal_set_z(float value) {
  
  z_ = value;
}
inline void Lidar_xyz::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:sensors.Lidar.xyz.z)
}

// -------------------------------------------------------------------

// Lidar

// float size = 1;
inline void Lidar::clear_size() {
  size_ = 0;
}
inline float Lidar::_internal_size() const {
  return size_;
}
inline float Lidar::size() const {
  // @@protoc_insertion_point(field_get:sensors.Lidar.size)
  return _internal_size();
}
inline void Lidar::_internal_set_size(float value) {
  
  size_ = value;
}
inline void Lidar::set_size(float value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:sensors.Lidar.size)
}

// repeated .sensors.Lidar.xyz data = 2;
inline int Lidar::_internal_data_size() const {
  return data_.size();
}
inline int Lidar::data_size() const {
  return _internal_data_size();
}
inline void Lidar::clear_data() {
  data_.Clear();
}
inline ::sensors::Lidar_xyz* Lidar::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:sensors.Lidar.data)
  return data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Lidar_xyz >*
Lidar::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:sensors.Lidar.data)
  return &data_;
}
inline const ::sensors::Lidar_xyz& Lidar::_internal_data(int index) const {
  return data_.Get(index);
}
inline const ::sensors::Lidar_xyz& Lidar::data(int index) const {
  // @@protoc_insertion_point(field_get:sensors.Lidar.data)
  return _internal_data(index);
}
inline ::sensors::Lidar_xyz* Lidar::_internal_add_data() {
  return data_.Add();
}
inline ::sensors::Lidar_xyz* Lidar::add_data() {
  // @@protoc_insertion_point(field_add:sensors.Lidar.data)
  return _internal_add_data();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sensors::Lidar_xyz >&
Lidar::data() const {
  // @@protoc_insertion_point(field_list:sensors.Lidar.data)
  return data_;
}

// -------------------------------------------------------------------

// Can

// float type = 1;
inline void Can::clear_type() {
  type_ = 0;
}
inline float Can::_internal_type() const {
  return type_;
}
inline float Can::type() const {
  // @@protoc_insertion_point(field_get:sensors.Can.type)
  return _internal_type();
}
inline void Can::_internal_set_type(float value) {
  
  type_ = value;
}
inline void Can::set_type(float value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sensors.Can.type)
}

// float data = 2;
inline void Can::clear_data() {
  data_ = 0;
}
inline float Can::_internal_data() const {
  return data_;
}
inline float Can::data() const {
  // @@protoc_insertion_point(field_get:sensors.Can.data)
  return _internal_data();
}
inline void Can::_internal_set_data(float value) {
  
  data_ = value;
}
inline void Can::set_data(float value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:sensors.Can.data)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sensors

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sensors::ChannelOrder> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensors::ChannelOrder>() {
  return ::sensors::ChannelOrder_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sensors_2eproto
